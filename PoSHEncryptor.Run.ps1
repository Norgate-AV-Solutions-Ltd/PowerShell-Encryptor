#------------------------------------------------------------------------
# Source File Information (DO NOT MODIFY)
# Source ID: eefe52f3-6419-496b-8cdf-dae3ba0d8283
# Source File: C:\Users\brw18\Google Drive\GitHub Projects\PowerShell-Encryptor\PoSHEncryptor.psproj
#------------------------------------------------------------------------
<#
    .NOTES
    --------------------------------------------------------------------------------
     Code generated by:  SAPIEN Technologies, Inc., PowerShell Studio 2017 v5.4.143
     Generated on:       9/17/2017 10:24 PM
     Generated by:       brw18
    --------------------------------------------------------------------------------
    .DESCRIPTION
        Script generated by PowerShell Studio 2017
#>



#region Source: Startup.pss
#----------------------------------------------
#region Import Assemblies
#----------------------------------------------
[void][Reflection.Assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
[void][Reflection.Assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
[void][Reflection.Assembly]::Load('System.DirectoryServices, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
#endregion Import Assemblies

#Define a Param block to use custom parameters in the project
#Param ($CustomParameter)

function Main {
<#
    .SYNOPSIS
        The Main function starts the project application.
    
    .PARAMETER Commandline
        $Commandline contains the complete argument string passed to the script packager executable.
    
    .NOTES
        Use this function to initialize your script and to call GUI forms.
		
    .NOTES
        To get the console output in the Packager (Forms Engine) use: 
		$ConsoleOutput (Type: System.Collections.ArrayList)
#>
	Param ([String]$Commandline)
		
	#--------------------------------------------------------------------------
	function New-AESKey()
	{
<#
.SYNOPSIS 
Generates a random AES key.

.DESCRIPTION
Generates a random AES key based on the desired key size.

.PARAMETER KeySize
Number of bits the generated key will have.

.EXAMPLE
$key = New-AESKey
This example generates a random 256-bit AES key and stores it in the variable $key.

.NOTES
Author: Tyler Siegrist
Date: 9/17/2017
#>
		[CmdletBinding()]
		[OutputType([String])]
		Param (
			[Parameter(Mandatory = $false, Position = 1)]
			[ValidateSet(128, 192, 256)]
			[Int]$KeySize = 256
		)
		
		$AESProvider = New-Object "System.Security.Cryptography.AesManaged"
		$AESProvider.KeySize = $KeySize
		$AESProvider.GenerateKey()
		return [System.Convert]::ToBase64String($AESProvider.Key)
	}
	
	Function Protect-File
	{
<#
.SYNOPSIS 
Encrypts a file using AES.

.DESCRIPTION
Encrypts a file using AES via a provided or randomly generated key.

.PARAMETER FileName
File(s) to be encrypted.

.PARAMETER Key
AES key to be used for encryption.

.PARAMETER Suffix
Suffix of the encrypted file to be removed.

.PARAMETER RemoveSource
Removes the source (decrypted) file after encrypting.

.EXAMPLE
Protect-File 'C:\secrets.txt' $key
This example encrypts C:\secrets.txt using the key stored in the variable $key. The encrypted file would have the default extension of '.AES' and the source (decrypted) file would not be removed.

.EXAMPLE
Protect-File 'C:\secrets.txt' -Suffix '.Encrypted' -RemoveSource
This example encrypts C:\secrets.txt with a randomly generated AES key. The encrypted file would have an extension of '.Encrypted' and the source (decrypted) file would be removed.

.EXAMPLE
Get-ChildItem 'C:\Files' -Recurse | Protect-File -Key $key -RemoveSource
This example encrypts all of the files under the C:\Files directory using the key stored in the variable $key. The encrypted files would have the default extension of '.AES' and the source (decrypted) files would be removed.

.NOTES
Author: Tyler Siegrist
Date: 9/17/2017
#>
		[CmdletBinding()]
		[OutputType([System.IO.FileInfo[]])]
		Param (
			[Parameter(Mandatory = $true, Position = 1, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
			[Alias('PSPath', 'LiteralPath')]
			[string[]]$FileName,
			[Parameter(Mandatory = $false, Position = 2)]
			[String]$Key = (New-AESKey),
			[Parameter(Mandatory = $false, Position = 3)]
			[String]$Suffix = '.AES',
			[Parameter()]
			[Switch]$RemoveSource
		)
		Begin
		{
			#Configure AES
			try
			{
				$EncryptionKey = [System.Convert]::FromBase64String($Key)
				$KeySize = $EncryptionKey.Length * 8
				$AESProvider = New-Object 'System.Security.Cryptography.AesManaged'
				$AESProvider.Mode = [System.Security.Cryptography.CipherMode]::CBC
				$AESProvider.BlockSize = 128
				$AESProvider.KeySize = $KeySize
				$AESProvider.Key = $EncryptionKey
			}
			Catch
			{
				Write-Error $_ -ErrorAction Stop
			}
		}
		Process
		{
			$Files = Get-Item -LiteralPath $FileName
			
			ForEach ($File in $Files)
			{
				$DestinationFile = $File.FullName + $Suffix
				
				Try
				{
					$FileStreamReader = New-Object System.IO.FileStream($File.FullName, [System.IO.FileMode]::Open)
					$FileStreamWriter = New-Object System.IO.FileStream($DestinationFile, [System.IO.FileMode]::Create)
					
					#Write IV (initialization-vector) length & IV to encrypted file
					$AESProvider.GenerateIV()
					$FileStreamWriter.Write([System.BitConverter]::GetBytes($AESProvider.IV.Length), 0, 4)
					$FileStreamWriter.Write($AESProvider.IV, 0, $AESProvider.IV.Length)
					
					#Perform encryption
					$Transform = $AESProvider.CreateEncryptor()
					$CryptoStream = New-Object System.Security.Cryptography.CryptoStream($FileStreamWriter, $Transform, [System.Security.Cryptography.CryptoStreamMode]::Write)
					[Int]$Count = 0
					[Int]$BlockSizeBytes = $AESProvider.BlockSize / 8
					[Byte[]]$Data = New-Object Byte[] $BlockSizeBytes
					Do
					{
						$Count = $FileStreamReader.Read($Data, 0, $BlockSizeBytes)
						$CryptoStream.Write($Data, 0, $Count)
					}
					While ($Count -gt 0)
					
					#Close open files
					$CryptoStream.FlushFinalBlock()
					$CryptoStream.Close()
					$FileStreamReader.Close()
					$FileStreamWriter.Close()
					
					#Output ecrypted file
					Get-Item $DestinationFile | Add-Member –MemberType NoteProperty –Name Key –Value $Key -PassThru | Add-Member –MemberType NoteProperty –Name SourceFile –Value $File.FullName -PassThru
					
					#Delete unencrypted file
					if ($RemoveSource) { Remove-Item -LiteralPath $File.FullName }
				}
				Catch
				{
					Write-Error $_
					If ($FileStreamWriter)
					{
						#Remove failed file
						Remove-Item -LiteralPath $DestinationFile -Force
					}
					Continue
				}
				Finally
				{
					if ($CryptoStream) { $CryptoStream.Close() }
					if ($FileStreamReader) { $FileStreamReader.Close() }
					if ($FileStreamWriter) { $FileStreamWriter.Close() }
				}
			}
		}
		End { }
	}
	
	Function Unprotect-File
	{
<#
.SYNOPSIS 
Decrypts an AES encrypted file.

.DESCRIPTION
Decrypts a file using a provided AES key.

.PARAMETER FileName
File(s) to be decrypted.

.PARAMETER Key
AES key to be used for decryption.

.PARAMETER Suffix
Suffix of the encrypted file to be removed.

.PARAMETER RemoveSource
Removes the source (encrypted) file after decrypting.

.EXAMPLE
Unprotect-File 'C:\secrets.txt.AES' $key
This example decrypts C:\secrets.txt.AES using the key stored in the variable $key. The decrypted file would remove the default extension of '.AES' and the source (encrypted) file would not be removed.

.EXAMPLE
Unprotect-File 'C:\secrets.txt.Encrypted' -Key $key -Suffix '.Encrypted' -RemoveSource
This example decrypts C:\secrets.txt.Encrypted using the key stored in the variable $key. The decrypted file would remove the extension of '.Encrypted' and the source (encrypted) file would be removed.

.EXAMPLE
Get-ChildItem 'C:\Files' -Recurse | Unprotect-File -Key $key -RemoveSource
This example decrypts all of the files under the C:\Files directory using the key stored in the variable $key. The decrypted files would remove the default extension of '.AES' and the source (encrypted) files would be removed.

.NOTES
Author: Tyler Siegrist
Date: 9/17/2017
#>
		[CmdletBinding()]
		[OutputType([System.IO.FileInfo[]])]
		Param (
			[Parameter(Mandatory = $true, Position = 1, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
			[Alias('PSPath', 'LiteralPath')]
			[string[]]$FileName,
			[Parameter(Mandatory = $true, Position = 2, ValueFromPipelineByPropertyName = $true)]
			[String]$Key,
			[Parameter(Mandatory = $false, Position = 3)]
			[String]$Suffix = '.AES',
			[Parameter()]
			[Switch]$RemoveSource
		)
		Process
		{
			#Configure AES
			try
			{
				$EncryptionKey = [System.Convert]::FromBase64String($Key)
				$KeySize = $EncryptionKey.Length * 8
				$AESProvider = New-Object 'System.Security.Cryptography.AesManaged'
				$AESProvider.Mode = [System.Security.Cryptography.CipherMode]::CBC
				$AESProvider.BlockSize = 128
				$AESProvider.KeySize = $KeySize
				$AESProvider.Key = $EncryptionKey
			}
			Catch
			{
				Write-Error $_ -ErrorAction Stop
			}
			
			#Used to store successfully decrypted file names.
			$Files = Get-Item -LiteralPath $FileName
			
			ForEach ($File in $Files)
			{
				#Verify file ends with supplied suffix
				If (-not $File.Name.EndsWith($Suffix))
				{
					Write-Error "$($File.FullName) does not have an extension of '$Suffix'."
					Continue
				}
				
				$DestinationFile = $File.FullName -replace "$Suffix$"
				
				Try
				{
					$FileStreamReader = New-Object System.IO.FileStream($File.FullName, [System.IO.FileMode]::Open)
					$FileStreamWriter = New-Object System.IO.FileStream($DestinationFile, [System.IO.FileMode]::Create)
					
					#Get IV from file
					[Byte[]]$LenIV = New-Object Byte[] 4
					$FileStreamReader.Seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null
					$FileStreamReader.Read($LenIV, 0, 3) | Out-Null
					[Int]$LIV = [System.BitConverter]::ToInt32($LenIV, 0)
					[Byte[]]$IV = New-Object Byte[] $LIV
					$FileStreamReader.Seek(4, [System.IO.SeekOrigin]::Begin) | Out-Null
					$FileStreamReader.Read($IV, 0, $LIV) | Out-Null
					$AESProvider.IV = $IV
					
					#Peform Decryption
					$Transform = $AESProvider.CreateDecryptor()
					[Int]$Count = 0
					[Int]$BlockSizeBytes = $AESProvider.BlockSize / 8
					[Byte[]]$Data = New-Object Byte[] $BlockSizeBytes
					$CryptoStream = New-Object System.Security.Cryptography.CryptoStream($FileStreamWriter, $Transform, [System.Security.Cryptography.CryptoStreamMode]::Write)
					Do
					{
						$Count = $FileStreamReader.Read($Data, 0, $BlockSizeBytes)
						$CryptoStream.Write($Data, 0, $Count)
					}
					While ($Count -gt 0)
					
					#Close open files
					$CryptoStream.FlushFinalBlock()
					$CryptoStream.Close()
					$FileStreamReader.Close()
					$FileStreamWriter.Close()
					
					#Output decrypted file
					Get-Item $DestinationFile | Add-Member –MemberType NoteProperty –Name SourceFile –Value $File.FullName -PassThru
					
					#Delete encrypted file
					if ($RemoveSource) { Remove-Item $File.FullName }
				}
				Catch
				{
					Write-Error $_
					If ($FileStreamWriter)
					{
						#Remove failed file
						Remove-Item -LiteralPath $DestinationFile -Force
					}
					Continue
				}
				Finally
				{
					if ($CryptoStream) { $CryptoStream.Close() }
					if ($FileStreamReader) { $FileStreamReader.Close() }
					if ($FileStreamWriter) { $FileStreamWriter.Close() }
				}
			}
		}
	}
	
	
	Function New-WPFMessageBox
	{
		
		# For examples for use, see my blog:
		# https://smsagent.wordpress.com/2017/08/24/a-customisable-wpf-messagebox-for-powershell/
		
		# CHANGES
		# 2017-09-11 - Added some required assemblies in the dynamic parameters to avoid errors when run from the PS console host.
		
		# Define Parameters
		[CmdletBinding()]
		Param
		(
			# The popup Content
			[Parameter(Mandatory = $True, Position = 0)]
			[Object]$Content,
			# The window title

			[Parameter(Mandatory = $false, Position = 1)]
			[string]$Title,
			# The buttons to add

			[Parameter(Mandatory = $false, Position = 2)]
			[ValidateSet('OK', 'OK-Cancel', 'Abort-Retry-Ignore', 'Yes-No-Cancel', 'Yes-No', 'Retry-Cancel', 'Cancel-TryAgain-Continue', 'None')]
			[array]$ButtonType = 'OK',
			# The buttons to add

			[Parameter(Mandatory = $false, Position = 3)]
			[array]$CustomButtons,
			# Content font size

			[Parameter(Mandatory = $false, Position = 4)]
			[int]$ContentFontSize = 14,
			# Title font size

			[Parameter(Mandatory = $false, Position = 5)]
			[int]$TitleFontSize = 14,
			# BorderThickness

			[Parameter(Mandatory = $false, Position = 6)]
			[int]$BorderThickness = 0,
			# CornerRadius

			[Parameter(Mandatory = $false, Position = 7)]
			[int]$CornerRadius = 8,
			# ShadowDepth

			[Parameter(Mandatory = $false, Position = 8)]
			[int]$ShadowDepth = 3,
			# BlurRadius

			[Parameter(Mandatory = $false, Position = 9)]
			[int]$BlurRadius = 20,
			# WindowHost

			[Parameter(Mandatory = $false, Position = 10)]
			[object]$WindowHost,
			# Timeout in seconds,

			[Parameter(Mandatory = $false, Position = 11)]
			[int]$Timeout,
			# Code for Window Loaded event,

			[Parameter(Mandatory = $false, Position = 12)]
			[scriptblock]$OnLoaded,
			# Code for Window Closed event,

			[Parameter(Mandatory = $false, Position = 13)]
			[scriptblock]$OnClosed
			
		)
		
		# Dynamically Populated parameters
		DynamicParam
		{
			
			# Add assemblies for use in PS Console 
			Add-Type -AssemblyName System.Drawing, PresentationCore
			
			# ContentBackground
			$ContentBackground = 'ContentBackground'
			$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
			$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
			$ParameterAttribute.Mandatory = $False
			$AttributeCollection.Add($ParameterAttribute)
			$RuntimeParameterDictionary = New-Object System.Management.Automation.RuntimeDefinedParameterDictionary
			$arrSet = [System.Drawing.Brushes] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
			$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
			$AttributeCollection.Add($ValidateSetAttribute)
			$PSBoundParameters.ContentBackground = "White"
			$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($ContentBackground, [string], $AttributeCollection)
			$RuntimeParameterDictionary.Add($ContentBackground, $RuntimeParameter)
			
			
			# FontFamily
			$FontFamily = 'FontFamily'
			$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
			$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
			$ParameterAttribute.Mandatory = $False
			$AttributeCollection.Add($ParameterAttribute)
			$arrSet = [System.Drawing.FontFamily]::Families | Select-Object -ExpandProperty Name
			$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
			$AttributeCollection.Add($ValidateSetAttribute)
			$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($FontFamily, [string], $AttributeCollection)
			$RuntimeParameterDictionary.Add($FontFamily, $RuntimeParameter)
			$PSBoundParameters.FontFamily = "Segui"
			
			# TitleFontWeight
			$TitleFontWeight = 'TitleFontWeight'
			$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
			$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
			$ParameterAttribute.Mandatory = $False
			$AttributeCollection.Add($ParameterAttribute)
			$arrSet = [System.Windows.FontWeights] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
			$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
			$AttributeCollection.Add($ValidateSetAttribute)
			$PSBoundParameters.TitleFontWeight = "Normal"
			$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($TitleFontWeight, [string], $AttributeCollection)
			$RuntimeParameterDictionary.Add($TitleFontWeight, $RuntimeParameter)
			
			# ContentFontWeight
			$ContentFontWeight = 'ContentFontWeight'
			$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
			$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
			$ParameterAttribute.Mandatory = $False
			$AttributeCollection.Add($ParameterAttribute)
			$arrSet = [System.Windows.FontWeights] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
			$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
			$AttributeCollection.Add($ValidateSetAttribute)
			$PSBoundParameters.ContentFontWeight = "Normal"
			$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($ContentFontWeight, [string], $AttributeCollection)
			$RuntimeParameterDictionary.Add($ContentFontWeight, $RuntimeParameter)
			
			
			# ContentTextForeground
			$ContentTextForeground = 'ContentTextForeground'
			$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
			$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
			$ParameterAttribute.Mandatory = $False
			$AttributeCollection.Add($ParameterAttribute)
			$arrSet = [System.Drawing.Brushes] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
			$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
			$AttributeCollection.Add($ValidateSetAttribute)
			$PSBoundParameters.ContentTextForeground = "Black"
			$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($ContentTextForeground, [string], $AttributeCollection)
			$RuntimeParameterDictionary.Add($ContentTextForeground, $RuntimeParameter)
			
			# TitleTextForeground
			$TitleTextForeground = 'TitleTextForeground'
			$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
			$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
			$ParameterAttribute.Mandatory = $False
			$AttributeCollection.Add($ParameterAttribute)
			$arrSet = [System.Drawing.Brushes] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
			$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
			$AttributeCollection.Add($ValidateSetAttribute)
			$PSBoundParameters.TitleTextForeground = "Black"
			$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($TitleTextForeground, [string], $AttributeCollection)
			$RuntimeParameterDictionary.Add($TitleTextForeground, $RuntimeParameter)
			
			# BorderBrush
			$BorderBrush = 'BorderBrush'
			$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
			$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
			$ParameterAttribute.Mandatory = $False
			$AttributeCollection.Add($ParameterAttribute)
			$arrSet = [System.Drawing.Brushes] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
			$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
			$AttributeCollection.Add($ValidateSetAttribute)
			$PSBoundParameters.BorderBrush = "Black"
			$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($BorderBrush, [string], $AttributeCollection)
			$RuntimeParameterDictionary.Add($BorderBrush, $RuntimeParameter)
			
			
			# TitleBackground
			$TitleBackground = 'TitleBackground'
			$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
			$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
			$ParameterAttribute.Mandatory = $False
			$AttributeCollection.Add($ParameterAttribute)
			$arrSet = [System.Drawing.Brushes] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
			$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
			$AttributeCollection.Add($ValidateSetAttribute)
			$PSBoundParameters.TitleBackground = "White"
			$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($TitleBackground, [string], $AttributeCollection)
			$RuntimeParameterDictionary.Add($TitleBackground, $RuntimeParameter)
			
			# ButtonTextForeground
			$ButtonTextForeground = 'ButtonTextForeground'
			$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
			$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
			$ParameterAttribute.Mandatory = $False
			$AttributeCollection.Add($ParameterAttribute)
			$arrSet = [System.Drawing.Brushes] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
			$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
			$AttributeCollection.Add($ValidateSetAttribute)
			$PSBoundParameters.ButtonTextForeground = "Black"
			$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($ButtonTextForeground, [string], $AttributeCollection)
			$RuntimeParameterDictionary.Add($ButtonTextForeground, $RuntimeParameter)
			
			# Sound
			$Sound = 'Sound'
			$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
			$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
			$ParameterAttribute.Mandatory = $False
			#$ParameterAttribute.Position = 14
			$AttributeCollection.Add($ParameterAttribute)
			$arrSet = (Get-ChildItem "$env:SystemDrive\Windows\Media" -Filter Windows* | Select-Object -ExpandProperty Name).Replace('.wav', '')
			$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
			$AttributeCollection.Add($ValidateSetAttribute)
			$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($Sound, [string], $AttributeCollection)
			$RuntimeParameterDictionary.Add($Sound, $RuntimeParameter)
			
			return $RuntimeParameterDictionary
		}
		
		Begin
		{
			Add-Type -AssemblyName PresentationFramework
		}
		
		Process
		{
			
			# Define the XAML markup
			[XML]$Xaml = @"
<Window 
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Name="Window" Title="" SizeToContent="WidthAndHeight" WindowStartupLocation="CenterScreen" WindowStyle="None" ResizeMode="NoResize" AllowsTransparency="True" Background="Transparent" Opacity="1">
    <Window.Resources>
        <Style TargetType="{x:Type Button}">
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border>
                            <Grid Background="{TemplateBinding Background}">
                                <ContentPresenter />
                            </Grid>
                        </Border>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </Window.Resources>
    <Border x:Name="MainBorder" Margin="10" CornerRadius="$CornerRadius" BorderThickness="$BorderThickness" BorderBrush="$($PSBoundParameters.BorderBrush)" Padding="0" >
        <Border.Effect>
            <DropShadowEffect x:Name="DSE" Color="Black" Direction="270" BlurRadius="$BlurRadius" ShadowDepth="$ShadowDepth" Opacity="0.6" />
        </Border.Effect>
        <Border.Triggers>
            <EventTrigger RoutedEvent="Window.Loaded">
                <BeginStoryboard>
                    <Storyboard>
                        <DoubleAnimation Storyboard.TargetName="DSE" Storyboard.TargetProperty="ShadowDepth" From="0" To="$ShadowDepth" Duration="0:0:1" AutoReverse="False" />
                        <DoubleAnimation Storyboard.TargetName="DSE" Storyboard.TargetProperty="BlurRadius" From="0" To="$BlurRadius" Duration="0:0:1" AutoReverse="False" />
                    </Storyboard>
                </BeginStoryboard>
            </EventTrigger>
        </Border.Triggers>
        <Grid >
            <Border Name="Mask" CornerRadius="$CornerRadius" Background="$($PSBoundParameters.ContentBackground)" />
            <Grid x:Name="Grid" Background="$($PSBoundParameters.ContentBackground)">
                <Grid.OpacityMask>
                    <VisualBrush Visual="{Binding ElementName=Mask}"/>
                </Grid.OpacityMask>
                <StackPanel Name="StackPanel" >                   
                    <TextBox Name="TitleBar" IsReadOnly="True" IsHitTestVisible="False" Text="$Title" Padding="10" FontFamily="$($PSBoundParameters.FontFamily)" FontSize="$TitleFontSize" Foreground="$($PSBoundParameters.TitleTextForeground)" FontWeight="$($PSBoundParameters.TitleFontWeight)" Background="$($PSBoundParameters.TitleBackground)" HorizontalAlignment="Stretch" VerticalAlignment="Center" Width="Auto" HorizontalContentAlignment="Center" BorderThickness="0"/>
                    <DockPanel Name="ContentHost" Margin="0,10,0,10"  >
                    </DockPanel>
                    <DockPanel Name="ButtonHost" LastChildFill="False" HorizontalAlignment="Center" >
                    </DockPanel>
                </StackPanel>
            </Grid>
        </Grid>
    </Border>
</Window>
"@
			
			[XML]$ButtonXaml = @"
<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Width="Auto" Height="30" FontFamily="Segui" FontSize="16" Background="Transparent" Foreground="White" BorderThickness="1" Margin="10" Padding="20,0,20,0" HorizontalAlignment="Right" Cursor="Hand"/>
"@
			
			[XML]$ButtonTextXaml = @"
<TextBlock xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" FontFamily="$($PSBoundParameters.FontFamily)" FontSize="16" Background="Transparent" Foreground="$($PSBoundParameters.ButtonTextForeground)" Padding="20,5,20,5" HorizontalAlignment="Center" VerticalAlignment="Center"/>
"@
			
			[XML]$ContentTextXaml = @"
<TextBlock xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Text="$Content" Foreground="$($PSBoundParameters.ContentTextForeground)" DockPanel.Dock="Right" HorizontalAlignment="Center" VerticalAlignment="Center" FontFamily="$($PSBoundParameters.FontFamily)" FontSize="$ContentFontSize" FontWeight="$($PSBoundParameters.ContentFontWeight)" TextWrapping="Wrap" Height="Auto" MaxWidth="500" MinWidth="50" Padding="10"/>
"@
			
			# Load the window from XAML
			$Window = [Windows.Markup.XamlReader]::Load((New-Object -TypeName System.Xml.XmlNodeReader -ArgumentList $xaml))
			
			# Custom function to add a button
			Function Add-Button
			{
				Param ($Content)
				$Button = [Windows.Markup.XamlReader]::Load((New-Object -TypeName System.Xml.XmlNodeReader -ArgumentList $ButtonXaml))
				$ButtonText = [Windows.Markup.XamlReader]::Load((New-Object -TypeName System.Xml.XmlNodeReader -ArgumentList $ButtonTextXaml))
				$ButtonText.Text = "$Content"
				$Button.Content = $ButtonText
				$Button.Add_MouseEnter({
						$This.Content.FontSize = "17"
					})
				$Button.Add_MouseLeave({
						$This.Content.FontSize = "16"
					})
				$Button.Add_Click({
						New-Variable -Name WPFMessageBoxOutput -Value $($This.Content.Text) -Option ReadOnly -Scope Script -Force
						$Window.Close()
					})
				$Window.FindName('ButtonHost').AddChild($Button)
			}
			
			# Add buttons
			If ($ButtonType -eq "OK")
			{
				Add-Button -Content "OK"
			}
			
			If ($ButtonType -eq "OK-Cancel")
			{
				Add-Button -Content "OK"
				Add-Button -Content "Cancel"
			}
			
			If ($ButtonType -eq "Abort-Retry-Ignore")
			{
				Add-Button -Content "Abort"
				Add-Button -Content "Retry"
				Add-Button -Content "Ignore"
			}
			
			If ($ButtonType -eq "Yes-No-Cancel")
			{
				Add-Button -Content "Yes"
				Add-Button -Content "No"
				Add-Button -Content "Cancel"
			}
			
			If ($ButtonType -eq "Yes-No")
			{
				Add-Button -Content "Yes"
				Add-Button -Content "No"
			}
			
			If ($ButtonType -eq "Retry-Cancel")
			{
				Add-Button -Content "Retry"
				Add-Button -Content "Cancel"
			}
			
			If ($ButtonType -eq "Cancel-TryAgain-Continue")
			{
				Add-Button -Content "Cancel"
				Add-Button -Content "TryAgain"
				Add-Button -Content "Continue"
			}
			
			If ($ButtonType -eq "None" -and $CustomButtons)
			{
				Foreach ($CustomButton in $CustomButtons)
				{
					Add-Button -Content "$CustomButton"
				}
			}
			
			# Remove the title bar if no title is provided
			If ($Title -eq "")
			{
				$TitleBar = $Window.FindName('TitleBar')
				$Window.FindName('StackPanel').Children.Remove($TitleBar)
			}
			
			# Add the Content
			If ($Content -is [String])
			{
				# Replace double quotes with single to avoid quote issues in strings
				If ($Content -match '"')
				{
					$Content = $Content.Replace('"', "'")
				}
				
				# Use a text box for a string value...
				$ContentTextBox = [Windows.Markup.XamlReader]::Load((New-Object -TypeName System.Xml.XmlNodeReader -ArgumentList $ContentTextXaml))
				$Window.FindName('ContentHost').AddChild($ContentTextBox)
			}
			Else
			{
				# ...or add a WPF element as a child
				Try
				{
					$Window.FindName('ContentHost').AddChild($Content)
				}
				Catch
				{
					$_
				}
			}
			
			# Enable window to move when dragged
			$Window.FindName('Grid').Add_MouseLeftButtonDown({
					$Window.DragMove()
				})
			
			# Activate the window on loading
			If ($OnLoaded)
			{
				$Window.Add_Loaded({
						$This.Activate()
						Invoke-Command $OnLoaded
					})
			}
			Else
			{
				$Window.Add_Loaded({
						$This.Activate()
					})
			}
			
			
			# Stop the dispatcher timer if exists
			If ($OnClosed)
			{
				$Window.Add_Closed({
						If ($DispatcherTimer)
						{
							$DispatcherTimer.Stop()
						}
						Invoke-Command $OnClosed
					})
			}
			Else
			{
				$Window.Add_Closed({
						If ($DispatcherTimer)
						{
							$DispatcherTimer.Stop()
						}
					})
			}
			
			
			# If a window host is provided assign it as the owner
			If ($WindowHost)
			{
				$Window.Owner = $WindowHost
				$Window.WindowStartupLocation = "CenterOwner"
			}
			
			# If a timeout value is provided, use a dispatcher timer to close the window when timeout is reached
			If ($Timeout)
			{
				$Stopwatch = New-object System.Diagnostics.Stopwatch
				$TimerCode = {
					If ($Stopwatch.Elapsed.TotalSeconds -ge $Timeout)
					{
						$Stopwatch.Stop()
						$Window.Close()
					}
				}
				$DispatcherTimer = New-Object -TypeName System.Windows.Threading.DispatcherTimer
				$DispatcherTimer.Interval = [TimeSpan]::FromSeconds(1)
				$DispatcherTimer.Add_Tick($TimerCode)
				$Stopwatch.Start()
				$DispatcherTimer.Start()
			}
			
			# Play a sound
			If ($($PSBoundParameters.Sound))
			{
				$SoundFile = "$env:SystemDrive\Windows\Media\$($PSBoundParameters.Sound).wav"
				$SoundPlayer = New-Object System.Media.SoundPlayer -ArgumentList $SoundFile
				$SoundPlayer.Add_LoadCompleted({
						$This.Play()
						$This.Dispose()
					})
				$SoundPlayer.LoadAsync()
			}
			
			# Display the window
			$null = $window.Dispatcher.InvokeAsync{ $window.ShowDialog() }.Wait()
			
		}
	}
	
	
	
	
	$RegKey = Get-Item 'HKCU:\Software\LBH Software, Inc.\Encryptor' -ErrorAction SilentlyContinue
	if (! $RegKey)
	{
		#Create the root key
		New-Item 'HKCU:\Software\LBH Software, Inc.\Encryptor' -Force
	}
	
	#--------------------------------------------------------------------------
	
	if((Show-MainForm_psf) -eq 'OK')
	{
		
	}
	
	$script:ExitCode = 0 #Set the exit code for the Packager
}







#endregion Source: Startup.pss

#region Source: MainForm.psf
function Show-MainForm_psf
{
	#----------------------------------------------
	#region Import the Assemblies
	#----------------------------------------------
	[void][reflection.assembly]::Load('System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Data, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089')
	[void][reflection.assembly]::Load('System.Drawing, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	[void][reflection.assembly]::Load('System.Design, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a')
	#endregion Import Assemblies

	#----------------------------------------------
	#region Generated Form Objects
	#----------------------------------------------
	[System.Windows.Forms.Application]::EnableVisualStyles()
	$formEncryptor = New-Object 'System.Windows.Forms.Form'
	$groupbox5 = New-Object 'System.Windows.Forms.GroupBox'
	$groupboxEncrypt = New-Object 'System.Windows.Forms.GroupBox'
	$radiobuttonFile = New-Object 'System.Windows.Forms.RadioButton'
	$radiobuttonDirectory = New-Object 'System.Windows.Forms.RadioButton'
	$groupbox1 = New-Object 'System.Windows.Forms.GroupBox'
	$labelEncryptionKey = New-Object 'System.Windows.Forms.Label'
	$labelFileFolder = New-Object 'System.Windows.Forms.Label'
	$textboxPATH = New-Object 'System.Windows.Forms.TextBox'
	$textboxKEY = New-Object 'System.Windows.Forms.TextBox'
	$buttonEncrypt = New-Object 'System.Windows.Forms.Button'
	$groupbox4 = New-Object 'System.Windows.Forms.GroupBox'
	$groupbox2 = New-Object 'System.Windows.Forms.GroupBox'
	$radioFileDecrypt = New-Object 'System.Windows.Forms.RadioButton'
	$radioDirectoryDecrypt = New-Object 'System.Windows.Forms.RadioButton'
	$buttonDecrypt = New-Object 'System.Windows.Forms.Button'
	$groupbox3 = New-Object 'System.Windows.Forms.GroupBox'
	$label1 = New-Object 'System.Windows.Forms.Label'
	$textboxDecryptKey = New-Object 'System.Windows.Forms.TextBox'
	$menustrip1 = New-Object 'System.Windows.Forms.MenuStrip'
	$fileToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$exitToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$toolsToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$encryptionToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$decryptionToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$clearEncryptionKeyToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$clearEncryptionPathToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$deSelectEncryptionRadioButtonsToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$deSelectDecryptionRadioButtonsToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$toolstripseparator1 = New-Object 'System.Windows.Forms.ToolStripSeparator'
	$aboutToolStripMenuItem = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$aboutToolStripMenuItem1 = New-Object 'System.Windows.Forms.ToolStripMenuItem'
	$InitialFormWindowState = New-Object 'System.Windows.Forms.FormWindowState'
	#endregion Generated Form Objects

	#----------------------------------------------
	# User Generated Script
	#----------------------------------------------
	
	$formEncryptor_Load = {
		function New-AESKey()
		{
	<#
	.SYNOPSIS 
	Generates a random AES key.
	
	.DESCRIPTION
	Generates a random AES key based on the desired key size.
	
	.PARAMETER KeySize
	Number of bits the generated key will have.
	
	.EXAMPLE
	$key = New-AESKey
	This example generates a random 256-bit AES key and stores it in the variable $key.
	
	.NOTES
	Author: Tyler Siegrist
	Date: 9/17/2017
	#>
			[CmdletBinding()]
			[OutputType([String])]
			Param (
				[Parameter(Mandatory = $false, Position = 1)]
				[ValidateSet(128, 192, 256)]
				[Int]$KeySize = 256
			)
			
			$AESProvider = New-Object "System.Security.Cryptography.AesManaged"
			$AESProvider.KeySize = $KeySize
			$AESProvider.GenerateKey()
			return [System.Convert]::ToBase64String($AESProvider.Key)
		}
		
		Function Protect-File
		{
	<#
	.SYNOPSIS 
	Encrypts a file using AES.
	
	.DESCRIPTION
	Encrypts a file using AES via a provided or randomly generated key.
	
	.PARAMETER FileName
	File(s) to be encrypted.
	
	.PARAMETER Key
	AES key to be used for encryption.
	
	.PARAMETER Suffix
	Suffix of the encrypted file to be removed.
	
	.PARAMETER RemoveSource
	Removes the source (decrypted) file after encrypting.
	
	.EXAMPLE
	Protect-File 'C:\secrets.txt' $key
	This example encrypts C:\secrets.txt using the key stored in the variable $key. The encrypted file would have the default extension of '.AES' and the source (decrypted) file would not be removed.
	
	.EXAMPLE
	Protect-File 'C:\secrets.txt' -Suffix '.Encrypted' -RemoveSource
	This example encrypts C:\secrets.txt with a randomly generated AES key. The encrypted file would have an extension of '.Encrypted' and the source (decrypted) file would be removed.
	
	.EXAMPLE
	Get-ChildItem 'C:\Files' -Recurse | Protect-File -Key $key -RemoveSource
	This example encrypts all of the files under the C:\Files directory using the key stored in the variable $key. The encrypted files would have the default extension of '.AES' and the source (decrypted) files would be removed.
	
	.NOTES
	Author: Tyler Siegrist
	Date: 9/17/2017
	#>
			[CmdletBinding()]
			[OutputType([System.IO.FileInfo[]])]
			Param (
				[Parameter(Mandatory = $true, Position = 1, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
				[Alias('PSPath', 'LiteralPath')]
				[string[]]$FileName,
				[Parameter(Mandatory = $false, Position = 2)]
				[String]$Key = (New-AESKey),
				[Parameter(Mandatory = $false, Position = 3)]
				[String]$Suffix = '.AES',
				[Parameter()]
				[Switch]$RemoveSource
			)
			Begin
			{
				#Configure AES
				try
				{
					$EncryptionKey = [System.Convert]::FromBase64String($Key)
					$KeySize = $EncryptionKey.Length * 8
					$AESProvider = New-Object 'System.Security.Cryptography.AesManaged'
					$AESProvider.Mode = [System.Security.Cryptography.CipherMode]::CBC
					$AESProvider.BlockSize = 128
					$AESProvider.KeySize = $KeySize
					$AESProvider.Key = $EncryptionKey
				}
				Catch
				{
					Write-Error $_ -ErrorAction Stop
				}
			}
			Process
			{
				$Files = Get-Item -LiteralPath $FileName
				
				ForEach ($File in $Files)
				{
					$DestinationFile = $File.FullName + $Suffix
					
					Try
					{
						$FileStreamReader = New-Object System.IO.FileStream($File.FullName, [System.IO.FileMode]::Open)
						$FileStreamWriter = New-Object System.IO.FileStream($DestinationFile, [System.IO.FileMode]::Create)
						
						#Write IV (initialization-vector) length & IV to encrypted file
						$AESProvider.GenerateIV()
						$FileStreamWriter.Write([System.BitConverter]::GetBytes($AESProvider.IV.Length), 0, 4)
						$FileStreamWriter.Write($AESProvider.IV, 0, $AESProvider.IV.Length)
						
						#Perform encryption
						$Transform = $AESProvider.CreateEncryptor()
						$CryptoStream = New-Object System.Security.Cryptography.CryptoStream($FileStreamWriter, $Transform, [System.Security.Cryptography.CryptoStreamMode]::Write)
						[Int]$Count = 0
						[Int]$BlockSizeBytes = $AESProvider.BlockSize / 8
						[Byte[]]$Data = New-Object Byte[] $BlockSizeBytes
						Do
						{
							$Count = $FileStreamReader.Read($Data, 0, $BlockSizeBytes)
							$CryptoStream.Write($Data, 0, $Count)
						}
						While ($Count -gt 0)
						
						#Close open files
						$CryptoStream.FlushFinalBlock()
						$CryptoStream.Close()
						$FileStreamReader.Close()
						$FileStreamWriter.Close()
						
						#Output ecrypted file
						Get-Item $DestinationFile | Add-Member –MemberType NoteProperty –Name Key –Value $Key -PassThru | Add-Member –MemberType NoteProperty –Name SourceFile –Value $File.FullName -PassThru
						
						#Delete unencrypted file
						if ($RemoveSource) { Remove-Item -LiteralPath $File.FullName }
					}
					Catch
					{
						Write-Error $_
						If ($FileStreamWriter)
						{
							#Remove failed file
							Remove-Item -LiteralPath $DestinationFile -Force
						}
						Continue
					}
					Finally
					{
						if ($CryptoStream) { $CryptoStream.Close() }
						if ($FileStreamReader) { $FileStreamReader.Close() }
						if ($FileStreamWriter) { $FileStreamWriter.Close() }
					}
				}
			}
			End { }
		}
		
		Function Unprotect-File
		{
	<#
	.SYNOPSIS 
	Decrypts an AES encrypted file.
	
	.DESCRIPTION
	Decrypts a file using a provided AES key.
	
	.PARAMETER FileName
	File(s) to be decrypted.
	
	.PARAMETER Key
	AES key to be used for decryption.
	
	.PARAMETER Suffix
	Suffix of the encrypted file to be removed.
	
	.PARAMETER RemoveSource
	Removes the source (encrypted) file after decrypting.
	
	.EXAMPLE
	Unprotect-File 'C:\secrets.txt.AES' $key
	This example decrypts C:\secrets.txt.AES using the key stored in the variable $key. The decrypted file would remove the default extension of '.AES' and the source (encrypted) file would not be removed.
	
	.EXAMPLE
	Unprotect-File 'C:\secrets.txt.Encrypted' -Key $key -Suffix '.Encrypted' -RemoveSource
	This example decrypts C:\secrets.txt.Encrypted using the key stored in the variable $key. The decrypted file would remove the extension of '.Encrypted' and the source (encrypted) file would be removed.
	
	.EXAMPLE
	Get-ChildItem 'C:\Files' -Recurse | Unprotect-File -Key $key -RemoveSource
	This example decrypts all of the files under the C:\Files directory using the key stored in the variable $key. The decrypted files would remove the default extension of '.AES' and the source (encrypted) files would be removed.
	
	.NOTES
	Author: Tyler Siegrist
	Date: 9/17/2017
	#>
			[CmdletBinding()]
			[OutputType([System.IO.FileInfo[]])]
			Param (
				[Parameter(Mandatory = $true, Position = 1, ValueFromPipeline = $true, ValueFromPipelineByPropertyName = $true)]
				[Alias('PSPath', 'LiteralPath')]
				[string[]]$FileName,
				[Parameter(Mandatory = $true, Position = 2, ValueFromPipelineByPropertyName = $true)]
				[String]$Key,
				[Parameter(Mandatory = $false, Position = 3)]
				[String]$Suffix = '.AES',
				[Parameter()]
				[Switch]$RemoveSource
			)
			Process
			{
				#Configure AES
				try
				{
					$EncryptionKey = [System.Convert]::FromBase64String($Key)
					$KeySize = $EncryptionKey.Length * 8
					$AESProvider = New-Object 'System.Security.Cryptography.AesManaged'
					$AESProvider.Mode = [System.Security.Cryptography.CipherMode]::CBC
					$AESProvider.BlockSize = 128
					$AESProvider.KeySize = $KeySize
					$AESProvider.Key = $EncryptionKey
				}
				Catch
				{
					Write-Error $_ -ErrorAction Stop
				}
				
				#Used to store successfully decrypted file names.
				$Files = Get-Item -LiteralPath $FileName
				
				ForEach ($File in $Files)
				{
					#Verify file ends with supplied suffix
					If (-not $File.Name.EndsWith($Suffix))
					{
						Write-Error "$($File.FullName) does not have an extension of '$Suffix'."
						Continue
					}
					
					$DestinationFile = $File.FullName -replace "$Suffix$"
					
					Try
					{
						$FileStreamReader = New-Object System.IO.FileStream($File.FullName, [System.IO.FileMode]::Open)
						$FileStreamWriter = New-Object System.IO.FileStream($DestinationFile, [System.IO.FileMode]::Create)
						
						#Get IV from file
						[Byte[]]$LenIV = New-Object Byte[] 4
						$FileStreamReader.Seek(0, [System.IO.SeekOrigin]::Begin) | Out-Null
						$FileStreamReader.Read($LenIV, 0, 3) | Out-Null
						[Int]$LIV = [System.BitConverter]::ToInt32($LenIV, 0)
						[Byte[]]$IV = New-Object Byte[] $LIV
						$FileStreamReader.Seek(4, [System.IO.SeekOrigin]::Begin) | Out-Null
						$FileStreamReader.Read($IV, 0, $LIV) | Out-Null
						$AESProvider.IV = $IV
						
						#Peform Decryption
						$Transform = $AESProvider.CreateDecryptor()
						[Int]$Count = 0
						[Int]$BlockSizeBytes = $AESProvider.BlockSize / 8
						[Byte[]]$Data = New-Object Byte[] $BlockSizeBytes
						$CryptoStream = New-Object System.Security.Cryptography.CryptoStream($FileStreamWriter, $Transform, [System.Security.Cryptography.CryptoStreamMode]::Write)
						Do
						{
							$Count = $FileStreamReader.Read($Data, 0, $BlockSizeBytes)
							$CryptoStream.Write($Data, 0, $Count)
						}
						While ($Count -gt 0)
						
						#Close open files
						$CryptoStream.FlushFinalBlock()
						$CryptoStream.Close()
						$FileStreamReader.Close()
						$FileStreamWriter.Close()
						
						#Output decrypted file
						Get-Item $DestinationFile | Add-Member –MemberType NoteProperty –Name SourceFile –Value $File.FullName -PassThru
						
						#Delete encrypted file
						if ($RemoveSource) { Remove-Item $File.FullName }
					}
					Catch
					{
						Write-Error $_
						If ($FileStreamWriter)
						{
							#Remove failed file
							Remove-Item -LiteralPath $DestinationFile -Force
						}
						Continue
					}
					Finally
					{
						if ($CryptoStream) { $CryptoStream.Close() }
						if ($FileStreamReader) { $FileStreamReader.Close() }
						if ($FileStreamWriter) { $FileStreamWriter.Close() }
					}
				}
			}
		}
		
		
		Function New-WPFMessageBox
		{
			
			# For examples for use, see my blog:
			# https://smsagent.wordpress.com/2017/08/24/a-customisable-wpf-messagebox-for-powershell/
			
			# CHANGES
			# 2017-09-11 - Added some required assemblies in the dynamic parameters to avoid errors when run from the PS console host.
			
			# Define Parameters
			[CmdletBinding()]
			Param
			(
				# The popup Content
				[Parameter(Mandatory = $True, Position = 0)]
				[Object]$Content,
				# The window title
	
				[Parameter(Mandatory = $false, Position = 1)]
				[string]$Title,
				# The buttons to add
	
				[Parameter(Mandatory = $false, Position = 2)]
				[ValidateSet('OK', 'OK-Cancel', 'Abort-Retry-Ignore', 'Yes-No-Cancel', 'Yes-No', 'Retry-Cancel', 'Cancel-TryAgain-Continue', 'None')]
				[array]$ButtonType = 'OK',
				# The buttons to add
	
				[Parameter(Mandatory = $false, Position = 3)]
				[array]$CustomButtons,
				# Content font size
	
				[Parameter(Mandatory = $false, Position = 4)]
				[int]$ContentFontSize = 14,
				# Title font size
	
				[Parameter(Mandatory = $false, Position = 5)]
				[int]$TitleFontSize = 14,
				# BorderThickness
	
				[Parameter(Mandatory = $false, Position = 6)]
				[int]$BorderThickness = 0,
				# CornerRadius
	
				[Parameter(Mandatory = $false, Position = 7)]
				[int]$CornerRadius = 8,
				# ShadowDepth
	
				[Parameter(Mandatory = $false, Position = 8)]
				[int]$ShadowDepth = 3,
				# BlurRadius
	
				[Parameter(Mandatory = $false, Position = 9)]
				[int]$BlurRadius = 20,
				# WindowHost
	
				[Parameter(Mandatory = $false, Position = 10)]
				[object]$WindowHost,
				# Timeout in seconds,
	
				[Parameter(Mandatory = $false, Position = 11)]
				[int]$Timeout,
				# Code for Window Loaded event,
	
				[Parameter(Mandatory = $false, Position = 12)]
				[scriptblock]$OnLoaded,
				# Code for Window Closed event,
	
				[Parameter(Mandatory = $false, Position = 13)]
				[scriptblock]$OnClosed
				
			)
			
			# Dynamically Populated parameters
			DynamicParam
			{
				
				# Add assemblies for use in PS Console 
				Add-Type -AssemblyName System.Drawing, PresentationCore
				
				# ContentBackground
				$ContentBackground = 'ContentBackground'
				$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
				$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
				$ParameterAttribute.Mandatory = $False
				$AttributeCollection.Add($ParameterAttribute)
				$RuntimeParameterDictionary = New-Object System.Management.Automation.RuntimeDefinedParameterDictionary
				$arrSet = [System.Drawing.Brushes] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
				$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
				$AttributeCollection.Add($ValidateSetAttribute)
				$PSBoundParameters.ContentBackground = "White"
				$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($ContentBackground, [string], $AttributeCollection)
				$RuntimeParameterDictionary.Add($ContentBackground, $RuntimeParameter)
				
				
				# FontFamily
				$FontFamily = 'FontFamily'
				$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
				$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
				$ParameterAttribute.Mandatory = $False
				$AttributeCollection.Add($ParameterAttribute)
				$arrSet = [System.Drawing.FontFamily]::Families | Select-Object -ExpandProperty Name
				$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
				$AttributeCollection.Add($ValidateSetAttribute)
				$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($FontFamily, [string], $AttributeCollection)
				$RuntimeParameterDictionary.Add($FontFamily, $RuntimeParameter)
				$PSBoundParameters.FontFamily = "Segui"
				
				# TitleFontWeight
				$TitleFontWeight = 'TitleFontWeight'
				$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
				$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
				$ParameterAttribute.Mandatory = $False
				$AttributeCollection.Add($ParameterAttribute)
				$arrSet = [System.Windows.FontWeights] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
				$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
				$AttributeCollection.Add($ValidateSetAttribute)
				$PSBoundParameters.TitleFontWeight = "Normal"
				$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($TitleFontWeight, [string], $AttributeCollection)
				$RuntimeParameterDictionary.Add($TitleFontWeight, $RuntimeParameter)
				
				# ContentFontWeight
				$ContentFontWeight = 'ContentFontWeight'
				$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
				$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
				$ParameterAttribute.Mandatory = $False
				$AttributeCollection.Add($ParameterAttribute)
				$arrSet = [System.Windows.FontWeights] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
				$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
				$AttributeCollection.Add($ValidateSetAttribute)
				$PSBoundParameters.ContentFontWeight = "Normal"
				$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($ContentFontWeight, [string], $AttributeCollection)
				$RuntimeParameterDictionary.Add($ContentFontWeight, $RuntimeParameter)
				
				
				# ContentTextForeground
				$ContentTextForeground = 'ContentTextForeground'
				$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
				$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
				$ParameterAttribute.Mandatory = $False
				$AttributeCollection.Add($ParameterAttribute)
				$arrSet = [System.Drawing.Brushes] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
				$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
				$AttributeCollection.Add($ValidateSetAttribute)
				$PSBoundParameters.ContentTextForeground = "Black"
				$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($ContentTextForeground, [string], $AttributeCollection)
				$RuntimeParameterDictionary.Add($ContentTextForeground, $RuntimeParameter)
				
				# TitleTextForeground
				$TitleTextForeground = 'TitleTextForeground'
				$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
				$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
				$ParameterAttribute.Mandatory = $False
				$AttributeCollection.Add($ParameterAttribute)
				$arrSet = [System.Drawing.Brushes] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
				$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
				$AttributeCollection.Add($ValidateSetAttribute)
				$PSBoundParameters.TitleTextForeground = "Black"
				$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($TitleTextForeground, [string], $AttributeCollection)
				$RuntimeParameterDictionary.Add($TitleTextForeground, $RuntimeParameter)
				
				# BorderBrush
				$BorderBrush = 'BorderBrush'
				$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
				$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
				$ParameterAttribute.Mandatory = $False
				$AttributeCollection.Add($ParameterAttribute)
				$arrSet = [System.Drawing.Brushes] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
				$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
				$AttributeCollection.Add($ValidateSetAttribute)
				$PSBoundParameters.BorderBrush = "Black"
				$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($BorderBrush, [string], $AttributeCollection)
				$RuntimeParameterDictionary.Add($BorderBrush, $RuntimeParameter)
				
				
				# TitleBackground
				$TitleBackground = 'TitleBackground'
				$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
				$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
				$ParameterAttribute.Mandatory = $False
				$AttributeCollection.Add($ParameterAttribute)
				$arrSet = [System.Drawing.Brushes] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
				$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
				$AttributeCollection.Add($ValidateSetAttribute)
				$PSBoundParameters.TitleBackground = "White"
				$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($TitleBackground, [string], $AttributeCollection)
				$RuntimeParameterDictionary.Add($TitleBackground, $RuntimeParameter)
				
				# ButtonTextForeground
				$ButtonTextForeground = 'ButtonTextForeground'
				$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
				$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
				$ParameterAttribute.Mandatory = $False
				$AttributeCollection.Add($ParameterAttribute)
				$arrSet = [System.Drawing.Brushes] | Get-Member -Static -MemberType Property | Select-Object -ExpandProperty Name
				$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
				$AttributeCollection.Add($ValidateSetAttribute)
				$PSBoundParameters.ButtonTextForeground = "Black"
				$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($ButtonTextForeground, [string], $AttributeCollection)
				$RuntimeParameterDictionary.Add($ButtonTextForeground, $RuntimeParameter)
				
				# Sound
				$Sound = 'Sound'
				$AttributeCollection = New-Object System.Collections.ObjectModel.Collection[System.Attribute]
				$ParameterAttribute = New-Object System.Management.Automation.ParameterAttribute
				$ParameterAttribute.Mandatory = $False
				#$ParameterAttribute.Position = 14
				$AttributeCollection.Add($ParameterAttribute)
				$arrSet = (Get-ChildItem "$env:SystemDrive\Windows\Media" -Filter Windows* | Select-Object -ExpandProperty Name).Replace('.wav', '')
				$ValidateSetAttribute = New-Object System.Management.Automation.ValidateSetAttribute($arrSet)
				$AttributeCollection.Add($ValidateSetAttribute)
				$RuntimeParameter = New-Object System.Management.Automation.RuntimeDefinedParameter($Sound, [string], $AttributeCollection)
				$RuntimeParameterDictionary.Add($Sound, $RuntimeParameter)
				
				return $RuntimeParameterDictionary
			}
			
			Begin
			{
				Add-Type -AssemblyName PresentationFramework
			}
			
			Process
			{
				
				# Define the XAML markup
				[XML]$Xaml = @"
<Window 
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        x:Name="Window" Title="" SizeToContent="WidthAndHeight" WindowStartupLocation="CenterScreen" WindowStyle="None" ResizeMode="NoResize" AllowsTransparency="True" Background="Transparent" Opacity="1">
    <Window.Resources>
        <Style TargetType="{x:Type Button}">
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border>
                            <Grid Background="{TemplateBinding Background}">
                                <ContentPresenter />
                            </Grid>
                        </Border>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </Window.Resources>
    <Border x:Name="MainBorder" Margin="10" CornerRadius="$CornerRadius" BorderThickness="$BorderThickness" BorderBrush="$($PSBoundParameters.BorderBrush)" Padding="0" >
        <Border.Effect>
            <DropShadowEffect x:Name="DSE" Color="Black" Direction="270" BlurRadius="$BlurRadius" ShadowDepth="$ShadowDepth" Opacity="0.6" />
        </Border.Effect>
        <Border.Triggers>
            <EventTrigger RoutedEvent="Window.Loaded">
                <BeginStoryboard>
                    <Storyboard>
                        <DoubleAnimation Storyboard.TargetName="DSE" Storyboard.TargetProperty="ShadowDepth" From="0" To="$ShadowDepth" Duration="0:0:1" AutoReverse="False" />
                        <DoubleAnimation Storyboard.TargetName="DSE" Storyboard.TargetProperty="BlurRadius" From="0" To="$BlurRadius" Duration="0:0:1" AutoReverse="False" />
                    </Storyboard>
                </BeginStoryboard>
            </EventTrigger>
        </Border.Triggers>
        <Grid >
            <Border Name="Mask" CornerRadius="$CornerRadius" Background="$($PSBoundParameters.ContentBackground)" />
            <Grid x:Name="Grid" Background="$($PSBoundParameters.ContentBackground)">
                <Grid.OpacityMask>
                    <VisualBrush Visual="{Binding ElementName=Mask}"/>
                </Grid.OpacityMask>
                <StackPanel Name="StackPanel" >                   
                    <TextBox Name="TitleBar" IsReadOnly="True" IsHitTestVisible="False" Text="$Title" Padding="10" FontFamily="$($PSBoundParameters.FontFamily)" FontSize="$TitleFontSize" Foreground="$($PSBoundParameters.TitleTextForeground)" FontWeight="$($PSBoundParameters.TitleFontWeight)" Background="$($PSBoundParameters.TitleBackground)" HorizontalAlignment="Stretch" VerticalAlignment="Center" Width="Auto" HorizontalContentAlignment="Center" BorderThickness="0"/>
                    <DockPanel Name="ContentHost" Margin="0,10,0,10"  >
                    </DockPanel>
                    <DockPanel Name="ButtonHost" LastChildFill="False" HorizontalAlignment="Center" >
                    </DockPanel>
                </StackPanel>
            </Grid>
        </Grid>
    </Border>
</Window>
"@
				
				[XML]$ButtonXaml = @"
<Button xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Width="Auto" Height="30" FontFamily="Segui" FontSize="16" Background="Transparent" Foreground="White" BorderThickness="1" Margin="10" Padding="20,0,20,0" HorizontalAlignment="Right" Cursor="Hand"/>
"@
				
				[XML]$ButtonTextXaml = @"
<TextBlock xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" FontFamily="$($PSBoundParameters.FontFamily)" FontSize="16" Background="Transparent" Foreground="$($PSBoundParameters.ButtonTextForeground)" Padding="20,5,20,5" HorizontalAlignment="Center" VerticalAlignment="Center"/>
"@
				
				[XML]$ContentTextXaml = @"
<TextBlock xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Text="$Content" Foreground="$($PSBoundParameters.ContentTextForeground)" DockPanel.Dock="Right" HorizontalAlignment="Center" VerticalAlignment="Center" FontFamily="$($PSBoundParameters.FontFamily)" FontSize="$ContentFontSize" FontWeight="$($PSBoundParameters.ContentFontWeight)" TextWrapping="Wrap" Height="Auto" MaxWidth="500" MinWidth="50" Padding="10"/>
"@
				
				# Load the window from XAML
				$Window = [Windows.Markup.XamlReader]::Load((New-Object -TypeName System.Xml.XmlNodeReader -ArgumentList $xaml))
				
				# Custom function to add a button
				Function Add-Button
				{
					Param ($Content)
					$Button = [Windows.Markup.XamlReader]::Load((New-Object -TypeName System.Xml.XmlNodeReader -ArgumentList $ButtonXaml))
					$ButtonText = [Windows.Markup.XamlReader]::Load((New-Object -TypeName System.Xml.XmlNodeReader -ArgumentList $ButtonTextXaml))
					$ButtonText.Text = "$Content"
					$Button.Content = $ButtonText
					$Button.Add_MouseEnter({
							$This.Content.FontSize = "17"
						})
					$Button.Add_MouseLeave({
							$This.Content.FontSize = "16"
						})
					$Button.Add_Click({
							New-Variable -Name WPFMessageBoxOutput -Value $($This.Content.Text) -Option ReadOnly -Scope Script -Force
							$Window.Close()
						})
					$Window.FindName('ButtonHost').AddChild($Button)
				}
				
				# Add buttons
				If ($ButtonType -eq "OK")
				{
					Add-Button -Content "OK"
				}
				
				If ($ButtonType -eq "OK-Cancel")
				{
					Add-Button -Content "OK"
					Add-Button -Content "Cancel"
				}
				
				If ($ButtonType -eq "Abort-Retry-Ignore")
				{
					Add-Button -Content "Abort"
					Add-Button -Content "Retry"
					Add-Button -Content "Ignore"
				}
				
				If ($ButtonType -eq "Yes-No-Cancel")
				{
					Add-Button -Content "Yes"
					Add-Button -Content "No"
					Add-Button -Content "Cancel"
				}
				
				If ($ButtonType -eq "Yes-No")
				{
					Add-Button -Content "Yes"
					Add-Button -Content "No"
				}
				
				If ($ButtonType -eq "Retry-Cancel")
				{
					Add-Button -Content "Retry"
					Add-Button -Content "Cancel"
				}
				
				If ($ButtonType -eq "Cancel-TryAgain-Continue")
				{
					Add-Button -Content "Cancel"
					Add-Button -Content "TryAgain"
					Add-Button -Content "Continue"
				}
				
				If ($ButtonType -eq "None" -and $CustomButtons)
				{
					Foreach ($CustomButton in $CustomButtons)
					{
						Add-Button -Content "$CustomButton"
					}
				}
				
				# Remove the title bar if no title is provided
				If ($Title -eq "")
				{
					$TitleBar = $Window.FindName('TitleBar')
					$Window.FindName('StackPanel').Children.Remove($TitleBar)
				}
				
				# Add the Content
				If ($Content -is [String])
				{
					# Replace double quotes with single to avoid quote issues in strings
					If ($Content -match '"')
					{
						$Content = $Content.Replace('"', "'")
					}
					
					# Use a text box for a string value...
					$ContentTextBox = [Windows.Markup.XamlReader]::Load((New-Object -TypeName System.Xml.XmlNodeReader -ArgumentList $ContentTextXaml))
					$Window.FindName('ContentHost').AddChild($ContentTextBox)
				}
				Else
				{
					# ...or add a WPF element as a child
					Try
					{
						$Window.FindName('ContentHost').AddChild($Content)
					}
					Catch
					{
						$_
					}
				}
				
				# Enable window to move when dragged
				$Window.FindName('Grid').Add_MouseLeftButtonDown({
						$Window.DragMove()
					})
				
				# Activate the window on loading
				If ($OnLoaded)
				{
					$Window.Add_Loaded({
							$This.Activate()
							Invoke-Command $OnLoaded
						})
				}
				Else
				{
					$Window.Add_Loaded({
							$This.Activate()
						})
				}
				
				
				# Stop the dispatcher timer if exists
				If ($OnClosed)
				{
					$Window.Add_Closed({
							If ($DispatcherTimer)
							{
								$DispatcherTimer.Stop()
							}
							Invoke-Command $OnClosed
						})
				}
				Else
				{
					$Window.Add_Closed({
							If ($DispatcherTimer)
							{
								$DispatcherTimer.Stop()
							}
						})
				}
				
				
				# If a window host is provided assign it as the owner
				If ($WindowHost)
				{
					$Window.Owner = $WindowHost
					$Window.WindowStartupLocation = "CenterOwner"
				}
				
				# If a timeout value is provided, use a dispatcher timer to close the window when timeout is reached
				If ($Timeout)
				{
					$Stopwatch = New-object System.Diagnostics.Stopwatch
					$TimerCode = {
						If ($Stopwatch.Elapsed.TotalSeconds -ge $Timeout)
						{
							$Stopwatch.Stop()
							$Window.Close()
						}
					}
					$DispatcherTimer = New-Object -TypeName System.Windows.Threading.DispatcherTimer
					$DispatcherTimer.Interval = [TimeSpan]::FromSeconds(1)
					$DispatcherTimer.Add_Tick($TimerCode)
					$Stopwatch.Start()
					$DispatcherTimer.Start()
				}
				
				# Play a sound
				If ($($PSBoundParameters.Sound))
				{
					$SoundFile = "$env:SystemDrive\Windows\Media\$($PSBoundParameters.Sound).wav"
					$SoundPlayer = New-Object System.Media.SoundPlayer -ArgumentList $SoundFile
					$SoundPlayer.Add_LoadCompleted({
							$This.Play()
							$This.Dispose()
						})
					$SoundPlayer.LoadAsync()
				}
				
				# Display the window
				$null = $window.Dispatcher.InvokeAsync{ $window.ShowDialog() }.Wait()
				
			}
		}
		
		
		
		
		$RegKey = Get-Item 'HKCU:\Software\LBH Software, Inc.\Encryptor' -ErrorAction SilentlyContinue
		if (! $RegKey)
		{
			#Create the root key
			New-Item 'HKCU:\Software\LBH Software, Inc.\Encryptor' -Force
		}
		$textboxKEY.Enabled = $False
	}
	
	$buttonCancel_Click={
		
	}
	
	$buttonEncrypt_Click={
		If ((!($radiobuttonDirectory.Checked)) -and (!($radiobuttonFile.Checked)))
		{
			$ErrorMsgParams = @{
				FontFamily		     = 'Calibri'
				Title			     = "ERROR!"
				TitleBackground	     = "Firebrick"
				TitleTextForeground  = "WhiteSmoke"
				TitleFontWeight	     = "UltraBold"
				TitleFontSize	     = 20
				Sound			     = 'Windows Exclamation'
			}
			New-WPFMessageBox @ErrorMsgParams -Content "Please select either a folder or directory to encrypt."
			}
		Else
		{
			If ($radiobuttonDirectory.Checked -eq $True)
			{
				If ($textboxPATH.text.Length -gt 2)
				{
					If ($textboxKEY.Text.Length -gt 2)
					{
						Try
						{
							$Key = $textboxKEY.text
							$textboxKEY.Enabled = $True
							$EncryptedDir = $textboxPATH.Text
							$Files = (Get-ChildItem $EncryptedDir -Recurse).VersionInfo.FileName
							ForEach ($File in $Files)
							{
								Protect-File -FileName $File -Key $Key
								Remove-Item $File -Confirm:$False -Force
								
							}
							$InfoParams = @{
								FontFamily			    = 'Calibri'
								Title				    = "INFORMATION"
								TitleFontSize		    = 20
								TitleBackground		    = 'LightSkyBlue'
								TitleTextForeground	    = 'DarkSlateGray'
							}
							New-WPFMessageBox @InfoParams -Content "Successfully encrypted $EncryptedDir"
						}
						Catch
						{
							[System.Windows.Forms.MessageBox]::Show("$_", "Error")
						}
					}
					Else
					{
						Try
						{
							$Key = New-AESKey
							$textboxKEY.Enabled = $True
							$textboxKEY.Text = $Key | Out-String
							$EncryptedDir = $textboxPATH.Text
							$Files = (Get-ChildItem $EncryptedDir -Recurse).VersionInfo.FileName
							ForEach ($File in $Files)
							{
								Protect-File -FileName $File -Key $Key
								Remove-Item $File -Confirm:$False -Force
								
							}
							$InfoParams = @{
								FontFamily				    = 'Calibri'
								Title					    = "INFORMATION"
								TitleFontSize			    = 20
								TitleBackground			    = 'LightSkyBlue'
								TitleTextForeground		    = 'DarkSlateGray'
							}
							New-WPFMessageBox @InfoParams -Content "Successfully encrypted $EncryptedDir"
						}
						Catch
						{
							[System.Windows.Forms.MessageBox]::Show("$_", "Error")
						}
					}
				}
				Else
				{
					$radiobuttonDirectory.Checked = $False
					$ErrorMsgParams = @{
						FontFamily				    = 'Calibri'
						Title					    = "ERROR!"
						TitleBackground			    = "Firebrick"
						TitleTextForeground		    = "WhiteSmoke"
						TitleFontWeight			    = "UltraBold"
						TitleFontSize			    = 20
						Sound					    = 'Windows Exclamation'
					}
					New-WPFMessageBox @ErrorMsgParams -Content "No directory has been selected! Please select a directory to encrypt."
				}
			}
			Elseif ($radiobuttonFile.Checked -eq $True)
			{
				If ($textboxPATH.text.Length -gt 2)
				{
					If ($textboxKEY.Text.Length -gt 2)
					{
						Try
						{
							$EncryptedFile = ($textboxPATH.text)
							$Key = $textboxKEY.Text
							$textboxKEY.Enabled = $True
							Protect-File -FileName $EncryptedFile -Key $Key
							Remove-Item $EncryptedFile -Force -Confirm:$False
							
							$InfoParams = @{
								FontFamily				   = 'Calibri'
								Title					   = "INFORMATION"
								TitleFontSize			   = 20
								TitleBackground		       = 'LightSkyBlue'
								TitleTextForeground	       = 'DarkSlateGray'
							}
							New-WPFMessageBox @InfoParams -Content "Successfully encrypted $EncryptedFile"
						}
						Catch
						{
							[System.Windows.Forms.MessageBox]::Show("$_", "Error")
						}
					}
					Else
					{
						Try
						{
							$EncryptedFile = ($textboxPATH.text)
							$Key = New-AESKey
							$textboxKEY.Enabled = $True
							$textboxKEY.Text = $Key | Out-String
							Protect-File -FileName $EncryptedFile -Key $Key
							Remove-Item $EncryptedFile -Force -Confirm:$False
							
							$InfoParams = @{
								FontFamily			      = 'Calibri'
								Title					  = "INFORMATION"
								TitleFontSize			  = 20
								TitleBackground		      = 'LightSkyBlue'
								TitleTextForeground	      = 'DarkSlateGray'
							}
							New-WPFMessageBox @InfoParams -Content "Successfully encrypted $EncryptedFile"
						}
						Catch
						{
							[System.Windows.Forms.MessageBox]::Show("$_", "Error")
						}
					}
				}
				Else
				{
					$radiobuttonFile.Checked = $False
					$ErrorMsgParams = @{
						FontFamily			      = 'Calibri'
						Title					  = "ERROR!"
						TitleBackground		      = "Firebrick"
						TitleTextForeground	      = "WhiteSmoke"
						TitleFontWeight		      = "UltraBold"
						TitleFontSize			  = 20
						Sound					  = 'Windows Exclamation'
					}
					New-WPFMessageBox @ErrorMsgParams -Content "No file has been selected! Please select a file to encrypt."
				}
			}
		}
	}
	
	$buttonDecrypt_Click = {
		$registryPath = 'HKCU:\Software\LBH Software, Inc.\Encryptor'
		$Name = "DecryptDirPath"
		$DecryptPath = (Get-ItemProperty -Path $registryPath).DecryptDirPath
		$NameFile = "DecryptFilePath"
		$DecryptFilePath = (Get-ItemProperty -Path $registryPath).DecryptFilePath
		If ((!($radioDirectoryDecrypt.Checked)) -and (!($radioFileDecrypt.Checked)))
		{
			$ErrorMsgParams = @{
				FontFamily			   = 'Calibri'
				Title				   = "ERROR!"
				TitleBackground	       = "Firebrick"
				TitleTextForeground    = "WhiteSmoke"
				TitleFontWeight	       = "UltraBold"
				TitleFontSize		   = 20
				Sound				   = 'Windows Exclamation'
			}
			New-WPFMessageBox @ErrorMsgParams -Content "Please select either a folder or directory to decrypt."
		}
		Else
		{
			If (!($textboxDecryptKey))
			{
				$InfoParams = @{
					FontFamily			      = 'Calibri'
					Title					  = "INFORMATION"
					TitleFontSize			  = 20
					TitleBackground		      = 'LightSkyBlue'
					TitleTextForeground	      = 'DarkSlateGray'
				}
				New-WPFMessageBox @InfoParams -Content "Please enter the decryption key"
			}
			Else
			{
				If ($radioDirectoryDecrypt.Checked -eq $True)
				{
					If ($DecryptPath -ne $Null)
					{
						Try
						{
							$DecryptDir = $DecryptPath
							$Key = $textboxDecryptKey.text
							
							$Files = (Get-ChildItem $DecryptDir -Recurse).VersionInfo.FileName
							ForEach ($File in $Files)
							{
								Unprotect-File -FileName $File -Key $Key
								Remove-Item $File -Confirm:$False -Force
								Remove-ItemProperty -Path $registryPath -Name $Name -Force -ErrorAction SilentlyContinue
								
							}
							$InfoParams = @{
								FontFamily				   = 'Calibri'
								Title					   = "INFORMATION"
								TitleFontSize			   = 20
								TitleBackground		       = 'LightSkyBlue'
								TitleTextForeground	       = 'DarkSlateGray'
							}
							New-WPFMessageBox @InfoParams -Content "Successfully decrypted $DecryptDir"
						}
						Catch
						{
							[System.Windows.Forms.MessageBox]::Show("$_", "Error")
						}
					}
					Else
					{
						$radioDirectoryDecrypt.Checked = $False
						$ErrorMsgParams = @{
							FontFamily			      = 'Calibri'
							Title					  = "ERROR!"
							TitleBackground		      = "Firebrick"
							TitleTextForeground	      = "WhiteSmoke"
							TitleFontWeight		      = "UltraBold"
							TitleFontSize			  = 20
							Sound					  = 'Windows Exclamation'
						}
						New-WPFMessageBox @ErrorMsgParams -Content "No directory has been selected! Please select a directory to decrypt."
					}
				}
				Elseif ($radioFileDecrypt.Checked -eq $True)
				{
					If ($DecryptFilePath -ne $Null)
					{
						Try
						{
							$Key = $textboxDecryptKey.text
							$File = $DecryptFilePath
							
							Unprotect-File -FileName $File -Key $Key
							Remove-Item $File -Confirm:$False -Force
							Remove-ItemProperty -Path $registryPath -Name $NameFile -Force -ErrorAction SilentlyContinue
							
							$InfoParams = @{
								FontFamily				    = 'Calibri'
								Title					    = "INFORMATION"
								TitleFontSize			    = 20
								TitleBackground			    = 'LightSkyBlue'
								TitleTextForeground		    = 'DarkSlateGray'
							}
							New-WPFMessageBox @InfoParams -Content "Successfully decrypted $DecryptFilePath"
						}
						Catch
						{
							[System.Windows.Forms.MessageBox]::Show("$_", "Error")
						}
					}
					Else
					{
						$radioDirectoryDecrypt.Checked = $False
						$ErrorMsgParams = @{
							FontFamily				   = 'Calibri'
							Title					   = "ERROR!"
							TitleBackground		       = "Firebrick"
							TitleTextForeground	       = "WhiteSmoke"
							TitleFontWeight		       = "UltraBold"
							TitleFontSize			   = 20
							Sound					   = 'Windows Exclamation'
						}
						New-WPFMessageBox @ErrorMsgParams -Content "No file has been selected! Please select a file to decrypt."
					}
				}
			}
			
		}
	}
	
	
	
	
	$radiobuttonFile_CheckedChanged={
		If ($radiobuttonFile.Checked -eq $True)
		{
			$savedialog = New-Object windows.forms.openfiledialog
			$savedialog.initialDirectory = [System.IO.Directory]::GetCurrentDirectory()
			$savedialog.title = "Encrypt File"
			$savedialog.ShowHelp = $True
			$resultfile = $savedialog.ShowDialog()
			$EncryptedFile = $savedialog.FileName
			$textboxPATH.Text = $EncryptedFile
			}
		
	}
	
	$radiobuttonDirectory_CheckedChanged={
		If ($radiobuttonDirectory.Checked -eq $True)
		{
			$savedialog = New-Object windows.forms.FolderBrowserDialog
			$savedialog.Description = "Please select a directory to encrypt"
			$resultDir = $savedialog.ShowDialog()
			$EncryptedDir = $savedialog.SelectedPath
			$textboxPATH.Text = $EncryptedDir 
		}
		
	}
	
	$radioDirectoryDecrypt_CheckedChanged={
		If ($radioDirectoryDecrypt.Checked -eq $True)
		{
			$savedialog = New-Object windows.forms.FolderBrowserDialog
			$savedialog.Description = "Please select a directory to decrypt"
			$resultDir = $savedialog.ShowDialog()
			$DecryptedDir = $savedialog.SelectedPath
			$registryPath = 'HKCU:\Software\LBH Software, Inc.\Encryptor'
			$Name = "DecryptDirPath"
			$value = $savedialog.SelectedPath 
			New-ItemProperty -Path $registryPath -Name $name -Value $value -PropertyType String -Force | Out-Null
		}
	}
	
	$radioFileDecrypt_CheckedChanged={
		If ($radioFileDecrypt.Checked -eq $True)
		{
			$savedialog = New-Object windows.forms.openfiledialog
			$savedialog.initialDirectory = [System.IO.Directory]::GetCurrentDirectory()
			$savedialog.title = "Encrypt File"
			$savedialog.ShowHelp = $True
			$resultfile = $savedialog.ShowDialog()
			$registryPath = 'HKCU:\Software\LBH Software, Inc.\Encryptor'
			$Name = "DecryptFilePath"
			$value = $savedialog.FileName
			New-ItemProperty -Path $registryPath -Name $name -Value $value -PropertyType String -Force | Out-Null
			
		}
		
	}
	
	$clearEncryptionKeyToolStripMenuItem_Click = {
		$textboxKEY.Enabled = $False
		$textboxKEY.Text = ""
		
	}
	
	$clearEncryptionPathToolStripMenuItem_Click={
		$textboxPATH.Text = ""
		
	}
	
	$deSelectDecryptionRadioButtonsToolStripMenuItem_Click={
		$radioDirectoryDecrypt.Checked = $False
		$radioFileDecrypt.Checked = $False
	}
	
	$deSelectEncryptionRadioButtonsToolStripMenuItem_Click={
		$radiobuttonDirectory.Checked = $False
		$radiobuttonFile.Checked = $False
		
	}
	
	$exitToolStripMenuItem_Click={
		$formEncryptor.Close()
		
	}
	
	$aboutToolStripMenuItem1_Click={
		$Params = @{
			FontFamily			   = 'Calibri'
			Title				   = "About"
			TitleFontSize		   = 20
			TitleTextForeground    = 'DarkSlateGray'
			TitleBackground	       = 'LightSkyBlue'
			ButtonType			   = 'OK'
			ContentFontSize	       = 16
			ContentTextForeground  = 'DarkSlateGray'
			ContentBackground	   = 'White'
			ButtonTextForeground   = 'DarkSlateGray'
			BorderThickness	       = 0
		}
		New-WPFMessageBox @Params -Content "Version: 1.0.0                                                                                                                         
Build Date: 9/17/2017                                                                                                                         
Encryption: AES-256                                                                                                                         
Encryption Module Author: Tyler Siegrist                                                                                                                          
Created By: Bradley Wyatt"
		
	}
		# --End User Generated Script--
	#----------------------------------------------
	#region Generated Events
	#----------------------------------------------
	
	$Form_StateCorrection_Load=
	{
		#Correct the initial state of the form to prevent the .Net maximized form issue
		$formEncryptor.WindowState = $InitialFormWindowState
	}
	
	$Form_StoreValues_Closing=
	{
		#Store the control values
		$script:MainForm_radiobuttonFile = $radiobuttonFile.Checked
		$script:MainForm_radiobuttonDirectory = $radiobuttonDirectory.Checked
		$script:MainForm_textboxPATH = $textboxPATH.Text
		$script:MainForm_textboxKEY = $textboxKEY.Text
		$script:MainForm_radioFileDecrypt = $radioFileDecrypt.Checked
		$script:MainForm_radioDirectoryDecrypt = $radioDirectoryDecrypt.Checked
		$script:MainForm_textboxDecryptKey = $textboxDecryptKey.Text
	}

	
	$Form_Cleanup_FormClosed=
	{
		#Remove all event handlers from the controls
		try
		{
			$radiobuttonFile.remove_CheckedChanged($radiobuttonFile_CheckedChanged)
			$radiobuttonDirectory.remove_CheckedChanged($radiobuttonDirectory_CheckedChanged)
			$buttonEncrypt.remove_Click($buttonEncrypt_Click)
			$radioFileDecrypt.remove_CheckedChanged($radioFileDecrypt_CheckedChanged)
			$radioDirectoryDecrypt.remove_CheckedChanged($radioDirectoryDecrypt_CheckedChanged)
			$buttonDecrypt.remove_Click($buttonDecrypt_Click)
			$formEncryptor.remove_Load($formEncryptor_Load)
			$exitToolStripMenuItem.remove_Click($exitToolStripMenuItem_Click)
			$clearEncryptionKeyToolStripMenuItem.remove_Click($clearEncryptionKeyToolStripMenuItem_Click)
			$clearEncryptionPathToolStripMenuItem.remove_Click($clearEncryptionPathToolStripMenuItem_Click)
			$deSelectEncryptionRadioButtonsToolStripMenuItem.remove_Click($deSelectEncryptionRadioButtonsToolStripMenuItem_Click)
			$deSelectDecryptionRadioButtonsToolStripMenuItem.remove_Click($deSelectDecryptionRadioButtonsToolStripMenuItem_Click)
			$aboutToolStripMenuItem1.remove_Click($aboutToolStripMenuItem1_Click)
			$formEncryptor.remove_Load($Form_StateCorrection_Load)
			$formEncryptor.remove_Closing($Form_StoreValues_Closing)
			$formEncryptor.remove_FormClosed($Form_Cleanup_FormClosed)
		}
		catch { Out-Null <# Prevent PSScriptAnalyzer warning #> }
	}
	#endregion Generated Events

	#----------------------------------------------
	#region Generated Form Code
	#----------------------------------------------
	$formEncryptor.SuspendLayout()
	$groupbox5.SuspendLayout()
	$groupboxEncrypt.SuspendLayout()
	$groupbox1.SuspendLayout()
	$groupbox4.SuspendLayout()
	$groupbox2.SuspendLayout()
	$groupbox3.SuspendLayout()
	$menustrip1.SuspendLayout()
	#
	# formEncryptor
	#
	$formEncryptor.Controls.Add($groupbox5)
	$formEncryptor.Controls.Add($groupbox4)
	$formEncryptor.Controls.Add($menustrip1)
	$formEncryptor.AutoScaleDimensions = '13, 26'
	$formEncryptor.AutoScaleMode = 'Font'
	$formEncryptor.ClientSize = '1263, 550'
	$formEncryptor.FormBorderStyle = 'FixedDialog'
	$formEncryptor.MainMenuStrip = $menustrip1
	$formEncryptor.Margin = '13, 12, 13, 12'
	$formEncryptor.MaximizeBox = $False
	$formEncryptor.MinimizeBox = $False
	$formEncryptor.Name = 'formEncryptor'
	$formEncryptor.StartPosition = 'CenterScreen'
	$formEncryptor.Text = 'Encryptor'
	$formEncryptor.add_Load($formEncryptor_Load)
	#
	# groupbox5
	#
	$groupbox5.Controls.Add($groupboxEncrypt)
	$groupbox5.Controls.Add($groupbox1)
	$groupbox5.Controls.Add($buttonEncrypt)
	$groupbox5.Location = '15, 64'
	$groupbox5.Margin = '6, 6, 6, 6'
	$groupbox5.Name = 'groupbox5'
	$groupbox5.Padding = '6, 6, 6, 6'
	$groupbox5.Size = '1231, 231'
	$groupbox5.TabIndex = 109
	$groupbox5.TabStop = $False
	$groupbox5.Text = 'Encryption'
	#
	# groupboxEncrypt
	#
	$groupboxEncrypt.Controls.Add($radiobuttonFile)
	$groupboxEncrypt.Controls.Add($radiobuttonDirectory)
	$groupboxEncrypt.Location = '12, 37'
	$groupboxEncrypt.Margin = '6, 6, 6, 6'
	$groupboxEncrypt.Name = 'groupboxEncrypt'
	$groupboxEncrypt.Padding = '6, 6, 6, 6'
	$groupboxEncrypt.Size = '247, 167'
	$groupboxEncrypt.TabIndex = 105
	$groupboxEncrypt.TabStop = $False
	$groupboxEncrypt.Text = 'Item'
	#
	# radiobuttonFile
	#
	$radiobuttonFile.Location = '12, 37'
	$radiobuttonFile.Margin = '6, 6, 6, 6'
	$radiobuttonFile.Name = 'radiobuttonFile'
	$radiobuttonFile.Size = '225, 48'
	$radiobuttonFile.TabIndex = 0
	$radiobuttonFile.TabStop = $True
	$radiobuttonFile.Text = 'File'
	$radiobuttonFile.UseVisualStyleBackColor = $True
	$radiobuttonFile.add_CheckedChanged($radiobuttonFile_CheckedChanged)
	#
	# radiobuttonDirectory
	#
	$radiobuttonDirectory.Location = '12, 97'
	$radiobuttonDirectory.Margin = '6, 6, 6, 6'
	$radiobuttonDirectory.Name = 'radiobuttonDirectory'
	$radiobuttonDirectory.Size = '225, 48'
	$radiobuttonDirectory.TabIndex = 1
	$radiobuttonDirectory.TabStop = $True
	$radiobuttonDirectory.Text = 'Directory'
	$radiobuttonDirectory.UseVisualStyleBackColor = $True
	$radiobuttonDirectory.add_CheckedChanged($radiobuttonDirectory_CheckedChanged)
	#
	# groupbox1
	#
	$groupbox1.Controls.Add($labelEncryptionKey)
	$groupbox1.Controls.Add($labelFileFolder)
	$groupbox1.Controls.Add($textboxPATH)
	$groupbox1.Controls.Add($textboxKEY)
	$groupbox1.Location = '271, 37'
	$groupbox1.Margin = '6, 6, 6, 6'
	$groupbox1.Name = 'groupbox1'
	$groupbox1.Padding = '6, 6, 6, 6'
	$groupbox1.Size = '740, 167'
	$groupbox1.TabIndex = 104
	$groupbox1.TabStop = $False
	$groupbox1.Text = 'Details'
	#
	# labelEncryptionKey
	#
	$labelEncryptionKey.AutoSize = $True
	$labelEncryptionKey.Location = '12, 116'
	$labelEncryptionKey.Margin = '6, 0, 6, 0'
	$labelEncryptionKey.Name = 'labelEncryptionKey'
	$labelEncryptionKey.Size = '159, 26'
	$labelEncryptionKey.TabIndex = 101
	$labelEncryptionKey.Text = 'Encryption Key'
	#
	# labelFileFolder
	#
	$labelFileFolder.AutoSize = $True
	$labelFileFolder.Location = '10, 45'
	$labelFileFolder.Margin = '6, 0, 6, 0'
	$labelFileFolder.Name = 'labelFileFolder'
	$labelFileFolder.Size = '114, 26'
	$labelFileFolder.TabIndex = 100
	$labelFileFolder.Text = 'File/Folder'
	#
	# textboxPATH
	#
	$textboxPATH.BackColor = 'Window'
	$textboxPATH.Location = '183, 45'
	$textboxPATH.Margin = '6, 6, 6, 6'
	$textboxPATH.Name = 'textboxPATH'
	$textboxPATH.ReadOnly = $True
	$textboxPATH.Size = '545, 32'
	$textboxPATH.TabIndex = 102
	#
	# textboxKEY
	#
	$textboxKEY.BackColor = 'Window'
	$textboxKEY.Location = '183, 113'
	$textboxKEY.Margin = '6, 6, 6, 6'
	$textboxKEY.Name = 'textboxKEY'
	$textboxKEY.ReadOnly = $True
	$textboxKEY.Size = '545, 32'
	$textboxKEY.TabIndex = 103
	#
	# buttonEncrypt
	#
	$buttonEncrypt.Location = '1052, 106'
	$buttonEncrypt.Margin = '6, 6, 6, 6'
	$buttonEncrypt.Name = 'buttonEncrypt'
	$buttonEncrypt.Size = '162, 46'
	$buttonEncrypt.TabIndex = 2
	$buttonEncrypt.Text = '&Encrypt'
	$buttonEncrypt.UseVisualStyleBackColor = $True
	$buttonEncrypt.add_Click($buttonEncrypt_Click)
	#
	# groupbox4
	#
	$groupbox4.Controls.Add($groupbox2)
	$groupbox4.Controls.Add($buttonDecrypt)
	$groupbox4.Controls.Add($groupbox3)
	$groupbox4.Location = '15, 307'
	$groupbox4.Margin = '6, 6, 6, 6'
	$groupbox4.Name = 'groupbox4'
	$groupbox4.Padding = '6, 6, 6, 6'
	$groupbox4.Size = '1231, 223'
	$groupbox4.TabIndex = 108
	$groupbox4.TabStop = $False
	$groupbox4.Text = 'Decryption'
	#
	# groupbox2
	#
	$groupbox2.Controls.Add($radioFileDecrypt)
	$groupbox2.Controls.Add($radioDirectoryDecrypt)
	$groupbox2.Location = '12, 37'
	$groupbox2.Margin = '6, 6, 6, 6'
	$groupbox2.Name = 'groupbox2'
	$groupbox2.Padding = '6, 6, 6, 6'
	$groupbox2.Size = '247, 167'
	$groupbox2.TabIndex = 106
	$groupbox2.TabStop = $False
	$groupbox2.Text = 'Item'
	#
	# radioFileDecrypt
	#
	$radioFileDecrypt.Location = '12, 37'
	$radioFileDecrypt.Margin = '6, 6, 6, 6'
	$radioFileDecrypt.Name = 'radioFileDecrypt'
	$radioFileDecrypt.Size = '225, 48'
	$radioFileDecrypt.TabIndex = 0
	$radioFileDecrypt.TabStop = $True
	$radioFileDecrypt.Text = 'File'
	$radioFileDecrypt.UseVisualStyleBackColor = $True
	$radioFileDecrypt.add_CheckedChanged($radioFileDecrypt_CheckedChanged)
	#
	# radioDirectoryDecrypt
	#
	$radioDirectoryDecrypt.Location = '12, 97'
	$radioDirectoryDecrypt.Margin = '6, 6, 6, 6'
	$radioDirectoryDecrypt.Name = 'radioDirectoryDecrypt'
	$radioDirectoryDecrypt.Size = '225, 48'
	$radioDirectoryDecrypt.TabIndex = 1
	$radioDirectoryDecrypt.TabStop = $True
	$radioDirectoryDecrypt.Text = 'Directory'
	$radioDirectoryDecrypt.UseVisualStyleBackColor = $True
	$radioDirectoryDecrypt.add_CheckedChanged($radioDirectoryDecrypt_CheckedChanged)
	#
	# buttonDecrypt
	#
	$buttonDecrypt.Location = '1052, 97'
	$buttonDecrypt.Margin = '6, 6, 6, 6'
	$buttonDecrypt.Name = 'buttonDecrypt'
	$buttonDecrypt.Size = '162, 46'
	$buttonDecrypt.TabIndex = 107
	$buttonDecrypt.Text = 'Decrypt'
	$buttonDecrypt.UseVisualStyleBackColor = $True
	$buttonDecrypt.add_Click($buttonDecrypt_Click)
	#
	# groupbox3
	#
	$groupbox3.Controls.Add($label1)
	$groupbox3.Controls.Add($textboxDecryptKey)
	$groupbox3.Location = '271, 37'
	$groupbox3.Margin = '6, 6, 6, 6'
	$groupbox3.Name = 'groupbox3'
	$groupbox3.Padding = '6, 6, 6, 6'
	$groupbox3.Size = '740, 167'
	$groupbox3.TabIndex = 105
	$groupbox3.TabStop = $False
	$groupbox3.Text = 'AES Key'
	#
	# label1
	#
	$label1.AutoSize = $True
	$label1.Location = '12, 80'
	$label1.Margin = '6, 0, 6, 0'
	$label1.Name = 'label1'
	$label1.Size = '159, 26'
	$label1.TabIndex = 101
	$label1.Text = 'Encryption Key'
	#
	# textboxDecryptKey
	#
	$textboxDecryptKey.BackColor = 'Window'
	$textboxDecryptKey.Location = '183, 77'
	$textboxDecryptKey.Margin = '6, 6, 6, 6'
	$textboxDecryptKey.Name = 'textboxDecryptKey'
	$textboxDecryptKey.Size = '545, 32'
	$textboxDecryptKey.TabIndex = 103
	#
	# menustrip1
	#
	[void]$menustrip1.Items.Add($fileToolStripMenuItem)
	[void]$menustrip1.Items.Add($toolsToolStripMenuItem)
	[void]$menustrip1.Items.Add($aboutToolStripMenuItem)
	$menustrip1.Location = '0, 0'
	$menustrip1.Name = 'menustrip1'
	$menustrip1.Padding = '13, 4, 0, 4'
	$menustrip1.Size = '1263, 44'
	$menustrip1.TabIndex = 110
	$menustrip1.Text = 'menustrip1'
	#
	# fileToolStripMenuItem
	#
	[void]$fileToolStripMenuItem.DropDownItems.Add($exitToolStripMenuItem)
	$fileToolStripMenuItem.Name = 'fileToolStripMenuItem'
	$fileToolStripMenuItem.Size = '63, 36'
	$fileToolStripMenuItem.Text = 'File'
	#
	# exitToolStripMenuItem
	#
	$exitToolStripMenuItem.Name = 'exitToolStripMenuItem'
	$exitToolStripMenuItem.Size = '152, 36'
	$exitToolStripMenuItem.Text = 'Exit'
	$exitToolStripMenuItem.add_Click($exitToolStripMenuItem_Click)
	#
	# toolsToolStripMenuItem
	#
	[void]$toolsToolStripMenuItem.DropDownItems.Add($encryptionToolStripMenuItem)
	[void]$toolsToolStripMenuItem.DropDownItems.Add($decryptionToolStripMenuItem)
	$toolsToolStripMenuItem.Name = 'toolsToolStripMenuItem'
	$toolsToolStripMenuItem.Size = '81, 36'
	$toolsToolStripMenuItem.Text = 'Tools'
	#
	# encryptionToolStripMenuItem
	#
	[void]$encryptionToolStripMenuItem.DropDownItems.Add($clearEncryptionKeyToolStripMenuItem)
	[void]$encryptionToolStripMenuItem.DropDownItems.Add($clearEncryptionPathToolStripMenuItem)
	[void]$encryptionToolStripMenuItem.DropDownItems.Add($toolstripseparator1)
	[void]$encryptionToolStripMenuItem.DropDownItems.Add($deSelectEncryptionRadioButtonsToolStripMenuItem)
	$encryptionToolStripMenuItem.Name = 'encryptionToolStripMenuItem'
	$encryptionToolStripMenuItem.Size = '201, 36'
	$encryptionToolStripMenuItem.Text = 'Encryption'
	#
	# decryptionToolStripMenuItem
	#
	[void]$decryptionToolStripMenuItem.DropDownItems.Add($deSelectDecryptionRadioButtonsToolStripMenuItem)
	$decryptionToolStripMenuItem.Name = 'decryptionToolStripMenuItem'
	$decryptionToolStripMenuItem.Size = '205, 36'
	$decryptionToolStripMenuItem.Text = 'Decryption'
	#
	# clearEncryptionKeyToolStripMenuItem
	#
	$clearEncryptionKeyToolStripMenuItem.Name = 'clearEncryptionKeyToolStripMenuItem'
	$clearEncryptionKeyToolStripMenuItem.Size = '315, 36'
	$clearEncryptionKeyToolStripMenuItem.Text = 'Clear Encryption Key'
	$clearEncryptionKeyToolStripMenuItem.add_Click($clearEncryptionKeyToolStripMenuItem_Click)
	#
	# clearEncryptionPathToolStripMenuItem
	#
	$clearEncryptionPathToolStripMenuItem.Name = 'clearEncryptionPathToolStripMenuItem'
	$clearEncryptionPathToolStripMenuItem.Size = '315, 36'
	$clearEncryptionPathToolStripMenuItem.Text = 'Clear Encryption Path'
	$clearEncryptionPathToolStripMenuItem.add_Click($clearEncryptionPathToolStripMenuItem_Click)
	#
	# deSelectEncryptionRadioButtonsToolStripMenuItem
	#
	$deSelectEncryptionRadioButtonsToolStripMenuItem.Name = 'deSelectEncryptionRadioButtonsToolStripMenuItem'
	$deSelectEncryptionRadioButtonsToolStripMenuItem.Size = '468, 36'
	$deSelectEncryptionRadioButtonsToolStripMenuItem.Text = 'De-Select Encryption Radio Buttons'
	$deSelectEncryptionRadioButtonsToolStripMenuItem.add_Click($deSelectEncryptionRadioButtonsToolStripMenuItem_Click)
	#
	# deSelectDecryptionRadioButtonsToolStripMenuItem
	#
	$deSelectDecryptionRadioButtonsToolStripMenuItem.Name = 'deSelectDecryptionRadioButtonsToolStripMenuItem'
	$deSelectDecryptionRadioButtonsToolStripMenuItem.Size = '472, 36'
	$deSelectDecryptionRadioButtonsToolStripMenuItem.Text = 'De-Select Decryption Radio Buttons'
	$deSelectDecryptionRadioButtonsToolStripMenuItem.add_Click($deSelectDecryptionRadioButtonsToolStripMenuItem_Click)
	#
	# toolstripseparator1
	#
	$toolstripseparator1.Name = 'toolstripseparator1'
	$toolstripseparator1.Size = '312, 6'
	#
	# aboutToolStripMenuItem
	#
	[void]$aboutToolStripMenuItem.DropDownItems.Add($aboutToolStripMenuItem1)
	$aboutToolStripMenuItem.Name = 'aboutToolStripMenuItem'
	$aboutToolStripMenuItem.Size = '76, 36'
	$aboutToolStripMenuItem.Text = 'Help'
	#
	# aboutToolStripMenuItem1
	#
	$aboutToolStripMenuItem1.Name = 'aboutToolStripMenuItem1'
	$aboutToolStripMenuItem1.Size = '153, 36'
	$aboutToolStripMenuItem1.Text = 'About'
	$aboutToolStripMenuItem1.add_Click($aboutToolStripMenuItem1_Click)
	$menustrip1.ResumeLayout()
	$groupbox3.ResumeLayout()
	$groupbox2.ResumeLayout()
	$groupbox4.ResumeLayout()
	$groupbox1.ResumeLayout()
	$groupboxEncrypt.ResumeLayout()
	$groupbox5.ResumeLayout()
	$formEncryptor.ResumeLayout()
	#endregion Generated Form Code

	#----------------------------------------------

	#Save the initial state of the form
	$InitialFormWindowState = $formEncryptor.WindowState
	#Init the OnLoad event to correct the initial state of the form
	$formEncryptor.add_Load($Form_StateCorrection_Load)
	#Clean up the control events
	$formEncryptor.add_FormClosed($Form_Cleanup_FormClosed)
	#Store the control values when form is closing
	$formEncryptor.add_Closing($Form_StoreValues_Closing)
	#Show the Form
	return $formEncryptor.ShowDialog()

}
#endregion Source: MainForm.psf

#region Source: Globals.ps1
function Invoke-Globals_ps1
{
	#--------------------------------------------
	# Declare Global Variables and Functions here
	#--------------------------------------------
	
	
	#Sample function that provides the location of the script
	function Get-ScriptDirectory
	{
	<#
		.SYNOPSIS
			Get-ScriptDirectory returns the proper location of the script.
	
		.OUTPUTS
			System.String
		
		.NOTES
			Returns the correct path within a packaged executable.
	#>
		[OutputType([string])]
		param ()
		if ($null -ne $hostinvocation)
		{
			Split-Path $hostinvocation.MyCommand.path
		}
		else
		{
			Split-Path $script:MyInvocation.MyCommand.Path
		}
	}
	
	#Sample variable that provides the location of the script
	[string]$ScriptDirectory = Get-ScriptDirectory
	
	
	
}
#endregion Source: Globals.ps1

#Start the application
Main ($CommandLine)
